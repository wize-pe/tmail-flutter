import 'dart:io';

import 'package:core/utils/app_logger.dart';
import 'package:dio/dio.dart';
import 'package:get/get_connect/http/src/status/http_status.dart';
import 'package:jmap_dart_client/jmap/core/error/method/error_method_response.dart';
import 'package:jmap_dart_client/jmap/core/error/method/exception/error_method_response_exception.dart';
import 'package:tmail_ui_user/features/login/domain/exceptions/authentication_exception.dart';
import 'package:tmail_ui_user/features/login/domain/exceptions/oauth_authorization_error.dart';
import 'package:tmail_ui_user/features/network_connection/presentation/network_connection_controller.dart'
  if (dart.library.html) 'package:tmail_ui_user/features/network_connection/presentation/web_network_connection_controller.dart';
import 'package:tmail_ui_user/main/exceptions/exception_thrower.dart';
import 'package:tmail_ui_user/main/exceptions/remote_exception.dart';
import 'package:tmail_ui_user/main/routes/route_navigation.dart';

class RemoteExceptionThrower extends ExceptionThrower {

  @override
  throwException(dynamic error, dynamic stackTrace) {
    logError('RemoteExceptionThrower::throwException():error: $error | stackTrace: $stackTrace');
    final networkConnectionController = getBinding<NetworkConnectionController>();
    if (networkConnectionController?.isNetworkConnectionAvailable() == false) {
      logError('RemoteExceptionThrower::throwException():isNetworkConnectionAvailable');
      throw const NoNetworkError();
    } else {
      handleDioError(error, stackTrace);
    }
  }

  void handleDioError(dynamic error, dynamic stackTrace) {
    if (error is DioError) {
      logError(
        'RemoteExceptionThrower::throwException():type: ${error.type} | response: ${error.response} | error: ${error.error}',
      );

      final response = error.response;
      final statusCode = response?.statusCode;

      if (response != null) {
        if (statusCode != HttpStatus.unauthorized) {
          reportToSentry(
            error,
            stackTrace,
            feature: 'Network',
            endpoint: response.realUri.path,
            statusCode: statusCode,
            additionalInfo: {
              'errorDescription': response.statusMessage,
            },
          );
        }

        switch (statusCode) {
          case HttpStatus.internalServerError:
            throw const InternalServerError();
          case HttpStatus.badGateway:
            throw BadGateway();
          case HttpStatus.unauthorized:
            throw const BadCredentialsException();
          default:
            throw UnknownError(
              code: statusCode,
              message: response.statusMessage,
            );
        }
      }

      return _handleDioErrorWithoutResponse(error, stackTrace);
    }

    if (error is ErrorMethodResponseException) {
      final errorResponse = error.errorResponse as ErrorMethodResponse;

      reportToSentry(
        error,
        stackTrace,
        feature: 'JMAP',
        additionalInfo: {
          'errorType': errorResponse.type,
          'errorDescription': errorResponse.description,
        },
      );

      if (errorResponse is CannotCalculateChangesMethodResponse) {
        throw CannotCalculateChangesMethodResponseException();
      } else {
        throw MethodLevelErrors(
          errorResponse.type,
          message: errorResponse.description,
        );
      }
    }

    reportToSentry(error, stackTrace);

    throw error;
  }

  void _handleDioErrorWithoutResponse(DioError error, dynamic stackTrace) {
    switch (error.type) {
      case DioErrorType.connectionTimeout:
        reportToSentry(
          error,
          stackTrace,
          feature: 'Network',
          additionalInfo: {
            'errorType': error.type.name,
          },
        );
        throw ConnectionTimeout(message: error.message);
      case DioErrorType.connectionError:
        reportToSentry(
          error,
          stackTrace,
          feature: 'Network',
          additionalInfo: {
            'errorType': error.type.name,
          },
        );
        throw ConnectionError(message: error.message);
      case DioErrorType.badResponse:
        throw const BadCredentialsException();
      default:
        final underlyingError = error.error;
        if (underlyingError is SocketException) {
          reportToSentry(
            error,
            stackTrace,
            feature: 'Network',
            additionalInfo: {
              'errorType': 'SocketException',
            },
          );
          throw const SocketError();
        } else if (underlyingError is OAuthAuthorizationError) {
          reportToSentry(
            error,
            stackTrace,
            feature: 'Network',
            additionalInfo: {
              'errorType': underlyingError.error,
              'errorDescription': underlyingError.errorDescription,
            },
          );
          throw underlyingError;
        } else if (underlyingError != null) {
          reportToSentry(
            error,
            stackTrace,
            feature: 'Network',
            additionalInfo: {
              'errorDescription': underlyingError.toString(),
            },
          );
          throw UnknownError(message: underlyingError);
        } else {
          reportToSentry(error, stackTrace, feature: 'Network');
          throw const UnknownError();
        }
    }
  }
}